/**
 * ESP32 CNC Controller
 * Controls a small CNC milling machine using GRBL-like commands
 */

#include <Arduino.h>
#include <WiFi.h>
#include <WebServer.h>
#include <AccelStepper.h>
#include <MultiStepper.h>
#include <ArduinoJson.h>
#include "FS.h"
#include "SD.h"
#include "SPI.h"

// Define pin connections for stepper motors
// X-axis stepper
#define X_STEP_PIN 12
#define X_DIR_PIN 14
#define X_ENABLE_PIN 13
#define X_LIMIT_PIN 36

// Y-axis stepper
#define Y_STEP_PIN 26
#define Y_DIR_PIN 25
#define Y_ENABLE_PIN 27
#define Y_LIMIT_PIN 39

// Z-axis stepper
#define Z_STEP_PIN 17
#define Z_DIR_PIN 16
#define Z_ENABLE_PIN 4
#define Z_LIMIT_PIN 34

// Spindle control
#define SPINDLE_PIN 2  // PWM pin for spindle speed control

// Emergency stop
#define ESTOP_PIN 35

// Other pins
#define SD_CS_PIN 5

// Network credentials
const char* ssid = "YOUR_WIFI_SSID";
const char* password = "YOUR_WIFI_PASSWORD";

// Web server
WebServer server(80);

// Create stepper instances
AccelStepper stepperX(AccelStepper::DRIVER, X_STEP_PIN, X_DIR_PIN);
AccelStepper stepperY(AccelStepper::DRIVER, Y_STEP_PIN, Y_DIR_PIN);
AccelStepper stepperZ(AccelStepper::DRIVER, Z_STEP_PIN, Z_DIR_PIN);

// Group the steppers for coordinated motion
MultiStepper steppers;

// Machine state variables
enum MachineState {IDLE, RUNNING, HOMING, ALARM, ESTOP};
MachineState currentState = IDLE;

// Machine parameters
struct {
  float stepsPerMmX = 80.0;  // Steps per mm for X axis
  float stepsPerMmY = 80.0;  // Steps per mm for Y axis
  float stepsPerMmZ = 160.0; // Steps per mm for Z axis (usually higher for finer control)
  float maxFeedRate = 1000;  // Maximum feed rate in mm/min
  float acceleration = 500;  // Acceleration in mm/sec^2
  bool homingEnabled = true;
  float homingFeedRate = 100; // Homing feed rate in mm/min
  float maxX = 200;  // Max X travel in mm
  float maxY = 200;  // Max Y travel in mm
  float maxZ = 100;  // Max Z travel in mm
} machineParams;

// Current position
float currentX = 0.0;
float currentY = 0.0;
float currentZ = 0.0;
int spindleSpeed = 0; // 0-255 for PWM control

// Buffer for G-code commands
String commandBuffer = "";
bool commandAvailable = false;

// Function prototypes
void handleHome();
void handleJog(float x, float y, float z, float feedRate);
void handleGcode(String gcode);
void parseGcode(String gcode);
void setupWiFi();
void setupServer();
bool checkLimits();
void emergencyStop();
void setupSteppers();
void runSpindle(int speed);

void setup() {
  Serial.begin(115200);
  Serial.println("ESP32 CNC Controller starting...");
  
  // Initialize pins
  pinMode(X_ENABLE_PIN, OUTPUT);
  pinMode(Y_ENABLE_PIN, OUTPUT);
  pinMode(Z_ENABLE_PIN, OUTPUT);
  pinMode(X_LIMIT_PIN, INPUT_PULLUP);
  pinMode(Y_LIMIT_PIN, INPUT_PULLUP);
  pinMode(Z_LIMIT_PIN, INPUT_PULLUP);
  pinMode(ESTOP_PIN, INPUT_PULLUP);
  pinMode(SPINDLE_PIN, OUTPUT);
  
  // Disable steppers by default
  digitalWrite(X_ENABLE_PIN, HIGH);
  digitalWrite(Y_ENABLE_PIN, HIGH);
  digitalWrite(Z_ENABLE_PIN, HIGH);
  
  // Initialize spindle
  ledcSetup(0, 5000, 8); // Channel 0, 5kHz, 8-bit resolution
  ledcAttachPin(SPINDLE_PIN, 0);
  runSpindle(0); // Ensure spindle is off on startup
  
  // Setup stepper motors
  setupSteppers();
  
  // Initialize SD card
  if (!SD.begin(SD_CS_PIN)) {
    Serial.println("SD card initialization failed");
  } else {
    Serial.println("SD card initialized");
  }
  
  // Setup WiFi and web server
  setupWiFi();
  setupServer();
  
  Serial.println("Setup complete - ready for commands");
}

void loop() {
  // Process web server requests
  server.handleClient();
  
  // Check for emergency stop
  if (digitalRead(ESTOP_PIN) == LOW && currentState != ESTOP) {
    emergencyStop();
  }
  
  // Check for limit switches if machine is moving
  if ((currentState == RUNNING || currentState == HOMING) && checkLimits()) {
    emergencyStop();
  }
  
  // Check serial for commands
  if (Serial.available() > 0) {
    char c = Serial.read();
    if (c == '\n') {
      commandAvailable = true;
    } else {
      commandBuffer += c;
    }
  }
  
  // Process command if one is available
  if (commandAvailable) {
    handleGcode(commandBuffer);
    commandBuffer = "";
    commandAvailable = false;
  }
  
  // Run the steppers
  if (currentState == RUNNING) {
    if (!stepperX.isRunning() && !stepperY.isRunning() && !stepperZ.isRunning()) {
      currentState = IDLE;
      Serial.println("Move complete");
    } else {
      stepperX.run();
      stepperY.run();
      stepperZ.run();
    }
  }
}

void setupSteppers() {
  // Configure stepper motors
  stepperX.setMaxSpeed(machineParams.stepsPerMmX * machineParams.maxFeedRate / 60.0);
  stepperX.setAcceleration(machineParams.stepsPerMmX * machineParams.acceleration);
  
  stepperY.setMaxSpeed(machineParams.stepsPerMmY * machineParams.maxFeedRate / 60.0);
  stepperY.setAcceleration(machineParams.stepsPerMmY * machineParams.acceleration);
  
  stepperZ.setMaxSpeed(machineParams.stepsPerMmZ * machineParams.maxFeedRate / 60.0);
  stepperZ.setAcceleration(machineParams.stepsPerMmZ * machineParams.acceleration);
  
  // Add steppers to multi stepper control
  steppers.addStepper(stepperX);
  steppers.addStepper(stepperY);
  steppers.addStepper(stepperZ);
  
  // Enable steppers
  digitalWrite(X_ENABLE_PIN, LOW);
  digitalWrite(Y_ENABLE_PIN, LOW);
  digitalWrite(Z_ENABLE_PIN, LOW);
}

void setupWiFi() {
  WiFi.begin(ssid, password);
  
  Serial.print("Connecting to WiFi");
  int attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 20) {
    delay(500);
    Serial.print(".");
    attempts++;
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\nWiFi connected");
    Serial.print("IP address: ");
    Serial.println(WiFi.localIP());
  } else {
    Serial.println("\nWiFi connection failed");
  }
}

void setupServer() {
  // Define server endpoints
  server.on("/", HTTP_GET, []() {
    String html = "<html><head><title>ESP32 CNC Controller</title></head><body>";
    html += "<h1>ESP32 CNC Controller</h1>";
    html += "<p>Machine Status: ";
    
    switch (currentState) {
      case IDLE: html += "IDLE"; break;
      case RUNNING: html += "RUNNING"; break;
      case HOMING: html += "HOMING"; break;
      case ALARM: html += "ALARM"; break;
      case ESTOP: html += "EMERGENCY STOP"; break;
    }
    
    html += "</p>";
    html += "<p>Position: X=" + String(currentX) + " Y=" + String(currentY) + " Z=" + String(currentZ) + "</p>";
    html += "<p>Spindle Speed: " + String(spindleSpeed) + "</p>";
    
    html += "<h2>Controls</h2>";
    html += "<button onclick=\"fetch('/home')\">Home</button> ";
    html += "<button onclick=\"fetch('/reset')\">Reset</button> ";
    
    html += "<h3>Jog Controls</h3>";
    html += "<button onclick=\"fetch('/jog?x=-10')\">X-10</button> ";
    html += "<button onclick=\"fetch('/jog?x=-1')\">X-1</button> ";
    html += "<button onclick=\"fetch('/jog?x=1')\">X+1</button> ";
    html += "<button onclick=\"fetch('/jog?x=10')\">X+10</button><br>";
    
    html += "<button onclick=\"fetch('/jog?y=-10')\">Y-10</button> ";
    html += "<button onclick=\"fetch('/jog?y=-1')\">Y-1</button> ";
    html += "<button onclick=\"fetch('/jog?y=1')\">Y+1</button> ";
    html += "<button onclick=\"fetch('/jog?y=10')\">Y+10</button><br>";
    
    html += "<button onclick=\"fetch('/jog?z=-10')\">Z-10</button> ";
    html += "<button onclick=\"fetch('/jog?z=-1')\">Z-1</button> ";
    html += "<button onclick=\"fetch('/jog?z=1')\">Z+1</button> ";
    html += "<button onclick=\"fetch('/jog?z=10')\">Z+10</button><br>";
    
    html += "<h3>Spindle Control</h3>";
    html += "<button onclick=\"fetch('/spindle?speed=0')\">Off</button> ";
    html += "<button onclick=\"fetch('/spindle?speed=128')\">Half</button> ";
    html += "<button onclick=\"fetch('/spindle?speed=255')\">Full</button><br>";
    
    html += "<h3>Send G-code</h3>";
    html += "<form action='/gcode' method='post'>";
    html += "<textarea name='code' rows='5' cols='40'></textarea><br>";
    html += "<input type='submit' value='Send'>";
    html += "</form>";
    
    html += "</body></html>";
    server.send(200, "text/html", html);
  });
  
  server.on("/home", HTTP_GET, []() {
    if (currentState == IDLE) {
      handleHome();
      server.send(200, "text/plain", "Homing started");
    } else {
      server.send(409, "text/plain", "Machine busy");
    }
  });
  
  server.on("/reset", HTTP_GET, []() {
    if (currentState == ALARM || currentState == ESTOP) {
      currentState = IDLE;
      // Re-enable steppers
      digitalWrite(X_ENABLE_PIN, LOW);
      digitalWrite(Y_ENABLE_PIN, LOW);
      digitalWrite(Z_ENABLE_PIN, LOW);
      server.send(200, "text/plain", "Machine reset");
    } else {
      server.send(409, "text/plain", "Machine not in alarm state");
    }
  });
  
  server.on("/jog", HTTP_GET, []() {
    if (currentState != IDLE) {
      server.send(409, "text/plain", "Machine busy");
      return;
    }
    
    float x = 0, y = 0, z = 0, f = machineParams.maxFeedRate / 2;
    
    for (int i = 0; i < server.args(); i++) {
      if (server.argName(i) == "x") x = server.arg(i).toFloat();
      else if (server.argName(i) == "y") y = server.arg(i).toFloat();
      else if (server.argName(i) == "z") z = server.arg(i).toFloat();
      else if (server.argName(i) == "f") f = server.arg(i).toFloat();
    }
    
    handleJog(x, y, z, f);
    server.send(200, "text/plain", "Jog command accepted");
  });
  
  server.on("/spindle", HTTP_GET, []() {
    if (server.hasArg("speed")) {
      int speed = server.arg("speed").toInt();
      speed = constrain(speed, 0, 255);
      runSpindle(speed);
      server.send(200, "text/plain", "Spindle speed set to " + String(speed));
    } else {
      server.send(400, "text/plain", "Missing speed parameter");
    }
  });
  
  server.on("/gcode", HTTP_POST, []() {
    if (currentState != IDLE) {
      server.send(409, "text/plain", "Machine busy");
      return;
    }
    
    if (server.hasArg("code")) {
      String gcode = server.arg("code");
      handleGcode(gcode);
      server.send(200, "text/plain", "G-code accepted");
    } else {
      server.send(400, "text/plain", "Missing code parameter");
    }
  });
  
  server.onNotFound([]() {
    server.send(404, "text/plain", "Not found");
  });
  
  server.begin();
  Serial.println("HTTP server started");
}

void handleHome() {
  if (!machineParams.homingEnabled) {
    Serial.println("Homing is disabled");
    return;
  }
  
  currentState = HOMING;
  Serial.println("Homing sequence started");
  
  // Home Z axis first (safer)
  stepperZ.setSpeed(-machineParams.stepsPerMmZ * machineParams.homingFeedRate / 60.0);
  while (digitalRead(Z_LIMIT_PIN) == HIGH) {
    stepperZ.runSpeed();
  }
  stepperZ.setCurrentPosition(0);
  
  // Back off a bit
  stepperZ.moveTo(5 * machineParams.stepsPerMmZ);
  while (stepperZ.isRunning()) {
    stepperZ.run();
  }
  
  // Go slow to the limit switch
  stepperZ.setSpeed(-machineParams.stepsPerMmZ * machineParams.homingFeedRate / 120.0);
  while (digitalRead(Z_LIMIT_PIN) == HIGH) {
    stepperZ.runSpeed();
  }
  stepperZ.setCurrentPosition(0);
  
  // Home X axis
  stepperX.setSpeed(-machineParams.stepsPerMmX * machineParams.homingFeedRate / 60.0);
  while (digitalRead(X_LIMIT_PIN) == HIGH) {
    stepperX.runSpeed();
  }
  stepperX.setCurrentPosition(0);
  
  // Home Y axis
  stepperY.setSpeed(-machineParams.stepsPerMmY * machineParams.homingFeedRate / 60.0);
  while (digitalRead(Y_LIMIT_PIN) == HIGH) {
    stepperY.runSpeed();
  }
  stepperY.setCurrentPosition(0);
  
  // Update current positions
  currentX = 0;
  currentY = 0;
  currentZ = 0;
  
  // Go to a safe position
  stepperZ.moveTo(10 * machineParams.stepsPerMmZ);  // Move Z up a bit
  while (stepperZ.isRunning()) {
    stepperZ.run();
  }
  currentZ = 10;
  
  currentState = IDLE;
  Serial.println("Homing complete");
}

void handleJog(float x, float y, float z, float feedRate) {
  // Calculate new positions
  float newX = currentX + x;
  float newY = currentY + y;
  float newZ = currentZ + z;
  
  // Check limits
  if (newX < 0) newX = 0;
  if (newY < 0) newY = 0;
  if (newZ < 0) newZ = 0;
  if (newX > machineParams.maxX) newX = machineParams.maxX;
  if (newY > machineParams.maxY) newY = machineParams.maxY;
  if (newZ > machineParams.maxZ) newZ = machineParams.maxZ;
  
  // Convert to steps
  long stepsX = long(newX * machineParams.stepsPerMmX);
  long stepsY = long(newY * machineParams.stepsPerMmY);
  long stepsZ = long(newZ * machineParams.stepsPerMmZ);
  
  // Set speeds
  float speedFactor = feedRate / 60.0;  // Convert mm/min to mm/sec
  stepperX.setMaxSpeed(machineParams.stepsPerMmX * speedFactor);
  stepperY.setMaxSpeed(machineParams.stepsPerMmY * speedFactor);
  stepperZ.setMaxSpeed(machineParams.stepsPerMmZ * speedFactor);
  
  // Move steppers
  stepperX.moveTo(stepsX);
  stepperY.moveTo(stepsY);
  stepperZ.moveTo(stepsZ);
  
  // Update state and current position
  currentState = RUNNING;
  currentX = newX;
  currentY = newY;
  currentZ = newZ;
  
  Serial.println("Jogging to X:" + String(newX) + " Y:" + String(newY) + " Z:" + String(newZ));
}

void handleGcode(String gcode) {
  Serial.println("G-code received: " + gcode);
  
  // Split into lines
  int startPos = 0;
  int endPos = gcode.indexOf('\n');
  
  while (endPos != -1) {
    String line = gcode.substring(startPos, endPos);
    line.trim();
    if (line.length() > 0 && line[0] != ';') {  // Skip empty lines and comments
      parseGcode(line);
    }
    startPos = endPos + 1;
    endPos = gcode.indexOf('\n', startPos);
  }
  
  // Process the last line if it exists
  if (startPos < gcode.length()) {
    String line = gcode.substring(startPos);
    line.trim();
    if (line.length() > 0 && line[0] != ';') {
      parseGcode(line);
    }
  }
}

void parseGcode(String line) {
  // Basic G-code parsing - supports G0, G1, M3, M5 commands
  
  // Remove comments
  int commentPos = line.indexOf(';');
  if (commentPos != -1) {
    line = line.substring(0, commentPos);
  }
  
  line.toUpperCase();
  line.trim();
  
  // Check if it's a movement command (G0 or G1)
  if (line.startsWith("G0") || line.startsWith("G1")) {
    float x = currentX;
    float y = currentY;
    float z = currentZ;
    float f = line.startsWith("G0") ? machineParams.maxFeedRate : machineParams.maxFeedRate / 2;
    
    // Extract parameters
    int paramPos = 2;  // Start after G0 or G1
    while (paramPos < line.length()) {
      char param = line.charAt(paramPos);
      paramPos++;
      
      if (paramPos >= line.length() || !isDigit(line.charAt(paramPos)) && line.charAt(paramPos) != '.' && line.charAt(paramPos) != '-') {
        continue;  // No value after parameter letter
      }
      
      // Find the end of the parameter value
      int valueStartPos = paramPos;
      while (paramPos < line.length() && (isDigit(line.charAt(paramPos)) || line.charAt(paramPos) == '.' || line.charAt(paramPos) == '-')) {
        paramPos++;
      }
      
      float value = line.substring(valueStartPos, paramPos).toFloat();
      
      // Assign to the right parameter
      switch (param) {
        case 'X': x = value; break;
        case 'Y': y = value; break;
        case 'Z': z = value; break;
        case 'F': f = value; break;
      }
    }
    
    // Execute movement
    if (x != currentX || y != currentY || z != currentZ) {
      handleJog(x - currentX, y - currentY, z - currentZ, f);
    }
  }
  // Spindle control
  else if (line.startsWith("M3") || line.startsWith("M4")) {  // Spindle on (clockwise or counterclockwise)
    int speed = 255;  // Default full speed
    
    // Extract S parameter for speed
    int sPos = line.indexOf('S');
    if (sPos != -1) {
      int valueStartPos = sPos + 1;
      int valueEndPos = valueStartPos;
      while (valueEndPos < line.length() && (isDigit(line.charAt(valueEndPos)) || line.charAt(valueEndPos) == '.')) {
        valueEndPos++;
      }
      
      if (valueEndPos > valueStartPos) {
        float speedPercent = line.substring(valueStartPos, valueEndPos).toFloat() / 100.0;
        speed = int(speedPercent * 255);
        speed = constrain(speed, 0, 255);
      }
    }
    
    runSpindle(speed);
  }
  else if (line.startsWith("M5")) {  // Spindle off
    runSpindle(0);
  }
}

bool checkLimits() {
  // Check if any limit switch is triggered
  if (digitalRead(X_LIMIT_PIN) == LOW || 
      digitalRead(Y_LIMIT_PIN) == LOW || 
      digitalRead(Z_LIMIT_PIN) == LOW) {
    Serial.println("Limit switch triggered!");
    return true;
  }
  return false;
}

void emergencyStop() {
  Serial.println("EMERGENCY STOP");
  
  // Stop all movement
  stepperX.stop();
  stepperY.stop();
  stepperZ.stop();
  
  // Disable steppers
  digitalWrite(X_ENABLE_PIN, HIGH);
  digitalWrite(Y_ENABLE_PIN, HIGH);
  digitalWrite(Z_ENABLE_PIN, HIGH);
  
  // Turn off spindle
  runSpindle(0);
  
  currentState = ESTOP;
}

void runSpindle(int speed) {
  spindleSpeed = speed;
  ledcWrite(0, speed);
  Serial.println("Spindle speed set to " + String(speed));
}